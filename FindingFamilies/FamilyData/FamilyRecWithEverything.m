//This a record for the families we will use. I think most entries are clear.
FamilyRecFinal := recformat<
    calG_level, B_level, calG_index, B_index, genus, sl2level, level, k, prec, commutator_index, maxprec,model_type, maxd,mind :RngIntElt,
    //k: the weight of modular forms used.  Not used.
    //prec: the precision used for modular forms.
    //commutator_index: index of the commutator subgroup
    //maxprec: maximum precision used
    //model_type: the type of our model. 5 if an elliptic curve, 8 if geometrically hyperelliptic, 0 if canonical model
    //maxd: maximum degree of the relations between modualr forms. this is used to compute the j map
    calG_gens, B_gens, subgroupsofH,jmap :SeqEnum,
    works: BoolElt,
    calG,B,H, commutator_sub, W :GrpMat,
    //calG is the agreeable group
    //W: calG meet SL2
    //B: A closed subgroup of GL2(Zhat) such that [calG,calG] \subseteq  B \subseteq W
    //commutator_sub: commutator subgroup of calG
    //H: a representative chosen in the family F(calG,B)
    onelementpossibly: BoolElt,
    CPname: MonStgElt,
    M, calGModCurve, AOfMF, quogroup, quomap, dataforquotient, conjugacyofB, transversals, nolift
    //M: the modular curve record of the representative H
    //calGModCurve: modualr curve recorf of calG. Will be used for relative j-maps
    //AOfMF: this contains the transformation matrices of the vector space generated by M`F. It is used for the computation of the cocycle. Short for Automorphism of Modular Forms
    //conjugacyofB: a list of subgroups of calG, consisting of conjugates of B in calG.
    //nolift: canonical model of H, only assigned when H is geometrically hyperelliptic
    //transversals: AOfMF for the canonical model
    //dataforquotient: Modular curve rec of calG. We obviously do not need this in all families. There is much room for improvement.
    >;




//Creates a family once we already have calG and B.

intrinsic CreateFamilyRec(calG::GrpMat, B::GrpMat, Hc::GrpMat, W::GrpMat, CPname::MonStgElt : compute_comm:=false, compute_calgmeetsl2:=false) -> Rec
 {
    Input:
        calG   : an agreeable subgroup of GL2(Zhat)
	    B      : an open subgroup of SL2(Zhat) such that [calG,calG] subseteq B subseteq SL2 meet calG
        Hc     : the commutator subgroup of calG
        W      : calG meet SL2
        CPname : the name of the intersection with SL2 in the Cummings-Pauli database
    Output:
        A record of type "FamilyRec" with the following entries computed:
            calG, B, calG_level, B_level, calG_gens, B_gens, W, genus, AOfMF, commutator_sub, CPname

 }

    F := rec<FamilyRecFinal | calG:= calG, B:=B >;
    calG_level:=GL2Level(calG);
    B_level:=SL2Level(B);
    //calG_index:=Index(GL(2,Integers(calG_level)),ChangeRing(calG,Integers(calG_level)));
    //B_index:=Index(SL(2,Integers(B_level)),ChangeRing(B,Integers(B_level)));
    genus:=GL2Genus(B);


    calG_gens:=[Eltseq(g): g in Generators(calG)];
    B_gens:=[Eltseq(g): g in Generators(B)];
    F`W:=W;
    F`calG_level:=calG_level;
    F`B_level:=B_level;
    F`genus:=genus;
    F`calG_gens:=calG_gens;
    F`B_gens:=B_gens;
    F`AOfMF:=AssociativeArray();
    F`commutator_sub:=Hc;
    F`CPname:=CPname;

    return F;
end intrinsic;
