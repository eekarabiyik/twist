load "../OpenImage/main/GL2GroupTheory.m";        
load "../OpenImage/main/ModularCurves.m";
load "../OpenImage/data-files/cyclic_invariant_polynomials.m";  


I:=Open("../OpenImage/data-files/agreeable.dat", "r"); 
X:=AssociativeArray();
repeat
	b,y:=ReadObjectCheck(I);
	if b then
		X[y`key]:=y;
	end if;
until not b;
// Setting some entries of X
for k in Keys(X) do
    if X[k]`genus le 1 then
        X[k]`map_to_jline:=[*MapTojLine(X,k)*];
    end if;
end for;
for k in Keys(X) do
    if X[k]`genus eq 0 and assigned X[k]`cyclic_models then
        K<x>:=FunctionField(X[k]`C);
        X[k]`cyclic_models:=[ [Evaluate(f,x): f in b]  :  b in X[k]`cyclic_models ];
    end if;
    if X[k]`genus eq 1 and assigned X[k]`cyclic_models then
        K<x,y>:=FunctionField(X[k]`C);
        X[k]`cyclic_models:=[ [Evaluate(f[1]/f[2],[x,y,1]): f in b]  :  b in X[k]`cyclic_models ];
    end if;
end for;



function ComputeFrobData0(n,p,c)
    /*
        Input:
            - n>1 is an integer; for now, in {2,3,4,5,8,9,16}
            - p is a prime
            - c is a sequence of elements in the finite field F_p

        Let m=phi(n). Let C be the companion matrix of the n-th cyclotomic polynomial.          
        We make use of certain sequence F of homogeneous polynomials in Z[x_1,..,x_m], that depend only on n, which 
        are given in the file "cyclic_invariant_polynomials.m".  The action of C on the polynomial ring fixes
        the polynomials F_i.    The sequence c of elements in F_p should have the same length as F.

        The subvariety of Z of AA^m over F_p defined by the polynomials F[i]-c[i] has an action of C.

        Output:  a boolean b and an integer e
            Suppose b is true. Then Z has dimension 0, degree n, and C acts simply transitively on the points of Z 
            (over an algebraic closure of F_p).  For any point of Z, applying the p-power Frobenius is the same as
            acting by C^e.
    */  

    if p eq 2 or n mod p eq 0 then
        return false, 0;
    end if;

    c:=[GF(p)!a: a in c];
    assert n in Keys(inv_polynomials);
    m:=EulerPhi(n);

    F:=inv_polynomials[n][2];   // Our polynomials F
 
    R<[x]>:=PolynomialRing(GF(p),m);
    psi:=[R!F[i]- c[i]: i in [1..#F]];

    // Want equations to define a reduced scheme of dimension 0 and degree n
    AA:=AffineSpace(GF(p),m);

    Z:=Scheme(AA,psi);

    if Dimension(Z) ne 0 or Degree(Z) ne n or IsReduced(Z) eq false then 
        return false, 0; 
    end if;

    // Choose an irreducible component Z1 of Z
    Z1:=IrreducibleComponents(Z)[1];

    d:=Degree(Z1); 
    FF:=GF(p^d); // smallest field over which Z1 has a FF-point
    P:=Rep( Points(ChangeRing(Z1,FF))); // pick a point

    C:=Transpose(CompanionMatrix(CyclotomicPolynomial(n)));  // transpose due to Magma's convention
    Cp:=ChangeRing(C,FF); // Matrix that should act simply transitively on FF-points of Z             

    Z:=ChangeRing(Z,FF);
    P:=Z!Eltseq(P); // We chose an FF-point of Z
    P_frob:=Z![a^p: a in Eltseq(P)];  // Apply p-th power Frobenius to P

    I:=[i: i in [0..n-1] | Matrix([Eltseq(P)])*Cp^i eq Matrix([Eltseq(P_frob)])];
    assert #I eq 1;
    e:=I[1]; //  Cp^e tales P to P_frob

    return true, e;
end function;


function ComputeFrobData(k,i, p : pt:=[])
    /*  
        k is a key of the array X of modular curves.  
    
        Set M=X[k]; it is a modular curve over Q of genus at most 1 with a rational point.
        Assume that the sequences M`cyclic_models and M`cyclic_invariants are both defined and consist of at least i elements.

        M`cyclic_models[i] defines a curve Y and a morphism Y->M; the morphism is Galois with Galois group 
        cyclic of prime power order n:=M`cyclic_invariants[i].    The model Y is given by equations of the form
            F(x_1,..,x_m)=c_F
        with F homogeneous polynomials and c_F in the function field of M.

        The polynomials F depend only on n and they are given in the file "cyclic_invariant_polynomials.m".  
        Let C be the companion matrix of the n-th cyclotomic polynomial.    The matrix
        C acts on our model by acting on the x_i.  Moreover, this action of C generates the Galois group of Y->M.

        We have a prime p.  Assume M has good reduction at p.  Assuming p is large enough, we can reduce our model modulo 
        p to get a cover of M modulo p that is still Galois with group generated by C.

        For an Fp-point point t of M, assume that the equations
            F(x_1,..,x_m)=c_F(t)
        define a finite reduced scheme over F_p of order n with the group generated by C acting transitive on the Fbar_p-points.   
        There is a unique nonnegative integer e<n such that p-power Frobenius and C^e act the same on the Fbar_p-points.

        We return a set consisting of pairs <t,e> as above for the given prime.   We might not return all such pairs, but
        the proportion of t in M(F_p) that appear as a first term will approach 1 as p grows.

        [ When "pt" is set to be a nonempty sequence of rational points of our modular curve; we will limit t to
          the reduction of points in this sequence]
    
    */

    n:=X[k]`cyclic_invariants[i];
    m:=EulerPhi(n);

    cover:=X[k]`cyclic_models[i]; 

    if  p eq 2 or n mod p eq 0 or (X[k]`genus eq 1 and p in BadPrimes(X[k]`C)) then
        return {};  // bad cases; let's return nothing        
    end if;

    if #pt eq 0 then
        // Find some points modulo p of our modular curve
        S:=Points(ChangeRing(X[k]`C,GF(p))); 
        if X[k]`genus eq 0 then
            S:={P:P in S | P[2] ne 0};
        else
            S:={P:P in S | P[3] ne 0};
        end if;
    else
        S:={ChangeRing(X[k]`C,GF(p))!pt};
        S:={P: P in S | P[#pt] ne 0};
    end if;

    pairs:={};

    R<[x]>:=PolynomialRing(GF(p),m);
    for t in S do 
        // try to specialize our cyclic covers at t; 
        // if valid (i.e., we don't divide by 0), we keep in a sequence F
        c:=[];
        for j in [1..#cover] do
            phi:=ProjectiveRationalFunction(cover[j]);    
            num:=Numerator(phi);        
            den:=Denominator(phi);  

            b:=LCM([Denominator(a):a in Coefficients(den)]);
            if b mod p eq 0 then continue t; end if;
            num:=b*num; den:=b*den;
            b:=LCM([Denominator(a):a in Coefficients(num)] cat [1]);
            if b mod p eq 0 then continue t; end if;
            num:=b*num; den:=b*den;

            num:=ChangeRing(num,Integers());         
            den:=ChangeRing(den,Integers());
        
            if Evaluate(den,Eltseq(t)) eq 0 then
                continue t;
            end if;

            c:=c cat [Evaluate(num,Eltseq(t))/Evaluate(den,Eltseq(t))];
        end for;

        b,e:=ComputeFrobData0(n,p,c);

        if not b then continue t; end if;
        
        pairs:=pairs join {<Eltseq(t),e>};
    end for;

    return pairs;
end function;


procedure PreComputationOfFrobData(filename,bound)
    /* For all appropriate k and i, and all primes 2<p <=bound, 
    we call "ComputeFrobData(k,i,p)" to get a set of pairs.    
    We save all this information to the file "filename".
    */

    cyclic_frobenius:=AssociativeArray();
    keys:=[k: k in Keys(X) | assigned X[k]`Gc_decomp and not X[k]`extraneous];

    keys:=[k: k in keys | 16 in X[k]`cyclic_invariants] cat [k: k in keys | 16 notin X[k]`cyclic_invariants];
    // order the sequence "keys" so that the most computationally intensive cases are done first

    for k in keys do
        X[k]`cyclic_invariants;
        cyclic_frobenius[k]:=AssociativeArray();
        for i in [1..#X[k]`Gc_decomp] do
            n:=X[k]`cyclic_invariants[i]; 

            PP:=[p: p in PrimesUpTo(bound) | p gt 2 and n mod p ne 0];
            if X[k]`genus eq 1 then
                PP:=[p: p in PP | p notin BadPrimes(X[k]`C)];
                assert IsMinimalModel(X[k]`C);
            end if;

            for p in PP do
                p;
                cyclic_frobenius[k][[i,p]]:=ComputeFrobData(k,i,p);            
            end for;

        end for;

    end for;

    I:=Open(filename,"w");
    WriteObject(I, bound);
    for k in Keys(cyclic_frobenius) do
    for a in Keys(cyclic_frobenius[k]) do
        y:=cyclic_frobenius[k][a];
        WriteObject(I, k);
        WriteObject(I, a);
        WriteObject(I, y);
    end for;
    end for;
end procedure;


